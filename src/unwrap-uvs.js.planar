const DEBUG = true;

const glm = require('glm-js');

function vertexToVec3({ x, y, z }) {
    return glm.vec3(x, y, z);
}

// https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal#Newell.27s_Method
function getFaceNormal(vertices) {
    const normal = glm.vec3(0, 0, 0);

    for (let i = 0; i < vertices.length; i += 1) {
        const current = vertices[i];
        const next = vertices[(i + 1) % vertices.length];

        normal[0] += (current[1] - next[1]) * (current[2] + next[2]);
        normal[1] += (current[2] - next[2]) * (current[0] + next[0]);
        normal[2] += (current[0] - next[0]) * (current[1] + next[1]);
    }

    return glm.normalize(normal);
}

const testVertices = [
    { x: 128, y: -24, z: 64 },
    { x: -128, y: -24, z: 64 },
    { x: -128, y: -24, z: -8 },
    { x: 128, y: -24, z: -8 }
];

function uvSort(uvs) {
    const centre = { u: 0, v: 0 };

    for (const vertex of uvs) {
        centre.u += vertex.u;
        centre.v += vertex.v;
    }

    centre.u /= uvs.length;
    centre.v /= uvs.length;

    // TODO may remove
    centre.u = 0.5;
    centre.v = 0.5;

    for (const [index, uv] of uvs.entries()) {
        uv.index = index;
        uv.angle = Math.atan2(uv.v - centre.v, uv.u - centre.u);
        //uv.angle = Math.atan2(uv.u - centre.u, uv.v - centre.v);
    }

    return uvs.sort((a, b) => {
        if (a.angle > b.angle) {
            return -1;
        }

        if (a.angle < b.angle) {
            return 1;
        }

        return 0;
    });
}

// https://gamedev.stackexchange.com/questions/129938/planar-mapping-projecting-uv-coordinates-from-normal
function unwrapUVs(vertices) {
    if (DEBUG) {
        console.log(vertices);
    }

    vertices = vertices.map((vertex) => vertexToVec3(vertex));

    const normal = getFaceNormal(vertices);

    if (DEBUG) {
        console.log(`normal=${normal}`);
    }

    let U = glm.cross(normal, glm.vec3(0, 0, 1));

    if (glm.dot(U, U) < 0.001) {
        U = glm.vec3(1, 0, 0);
    } else {
        U = glm.normalize(U);
    }

    const V = glm.normalize(glm.cross(U, normal));

    //console.log(U.toString(), V.toString());

    let uvs = [];

    let minU = 0;
    let minV = 0;

    let maxU = 0;
    let maxV = 0;

    for (const [index, vertex] of vertices.entries()) {
        const u = glm.dot(vertex, U);
        const v = glm.dot(vertex, V);

        if (index === 0 || u < minU) {
            minU = u;
        }

        if (index === 0 || v < minV) {
            minV = v;
        }

        if (index === 0 || u > maxU) {
            maxU = u;
        }

        if (index === 0 || v > maxV) {
            maxV = v;
        }

        uvs.push({ u, v });
    }

    if (DEBUG) {
        console.log('old uvs=', uvs);
        console.log('minV=', minV);
        console.log('maxV=', maxV);
    }

    uvs = uvs.map(({ u, v }) => {
        return {
            u: (u - minU) / (maxU - minU),
            v: (v - minV) / (maxV - minV)
        };
    });

    if (DEBUG) {
        console.log('uvs=', uvs);
        console.log();
    }

    return uvs;
}

//console.log(unwrapUVs(testVertices));

module.exports = unwrapUVs;
