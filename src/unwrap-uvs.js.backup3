const getPlaneNormal = require('get-plane-normal');

function getMinPlane(vertices, plane) {
    return Math.min(
        ...vertices.map((vertex) => {
            return vertex[plane];
        })
    );
}

function getMaxPlane(vertices, plane) {
    return Math.max(
        ...vertices.map((vertex) => {
            return vertex[plane];
        })
    );
}

function getMaxChange(vertices, plane) {
    let largest = 0;

    for (let i = 1; i < vertices.length; i++) {
        const delta = Math.abs(vertices[i][plane] - vertices[i - 1][plane]);

        if (delta > largest) {
            largest = delta;
        }
    }

    return largest;
}

function getAverageChange(vertices, plane) {
    let total = 0;

    for (let i = 1; i < vertices.length; i++) {
        const delta = Math.abs(vertices[i][plane] - vertices[i - 1][plane]);
        total += delta;
    }

    return total / (vertices.length - 1);
}

function getArea(vertices, ignore) {
    let uPlane = 'x';
    let vPlane = 'y';

    if (ignore == 'x') {
        uPlane = 'y';
        vPlane = 'z';
    } else if (ignore == 'y') {
        vPlane = 'z';
    }

    let leftSum = 0;
    let rightSum = 0;

    for (let i = 0; i < vertices.length; i++) {
        const j = (i + 1) % vertices.length;
        leftSum += vertices[i][uPlane] * vertices[j][vPlane];
        rightSum += vertices[j][uPlane] * vertices[i][vPlane];
    }

    return 0.5 * (leftSum - rightSum); // removed abs
}

function vertexToArray({ x, y, z }) {
    return [x, y, z];
}

function arrayToVertex([x, y, z]) {
    return { x, y, z };
}

function rotationalSort(vertices, uPlane, vPlane) {
    const centre = {};
    centre[uPlane] = 0;
    centre[vPlane] = 0;

    for (const vertex of vertices) {
        centre[uPlane] += vertex[uPlane];
        centre[vPlane] += vertex[vPlane];
    }

    centre[uPlane] /= vertices.length;
    centre[vPlane] /= vertices.length;

    for (const vertex of vertices) {
        vertex.angle = Math.abs(Math.atan2(
            vertex[uPlane] - centre[uPlane],
            vertex[vPlane] - centre[vPlane]
        ));
    }

    const entries = Array.from(vertices.entries()).sort((a, b) => {
        if (a[1].angle > b[1].angle) {
            return 1;
        }

        if (a[1].angle < b[1].angle) {
            return -1;
        }

        return 0;
    });

    return entries.map((entry) => entry[0]);
}

function uvSort(uvs) {
    const centre = { u: 0, v: 0 };

    // TODO try common centre.
    for (const vertex of uvs) {
        centre.u += vertex.u;
        centre.v += vertex.v;
    }

    centre.u /= uvs.length;
    centre.v /= uvs.length;

    centre.u = 0.5;
    centre.v = 0.5;

    for (const uv of uvs) {
        uv.angle = Math.atan2(uv.v - centre.v, uv.u - centre.u);
    }

    return uvs.sort((a, b) => {
        if (a.angle > b.angle) {
            return -1;
        }

        if (a.angle < b.angle) {
            return 1;
        }

        return 0;
    });
}

console.log(uvSort([
    { u: 0, v: 1 },
    { u: 1, v: 0.5 },
    { u: 0, v: 0 },

    /*{ u: 1, v: 1 },
    { u: 0, v: 1 },
    { u: 0, v: 0 },
    { u: 1, v: 0 }*/
]));

function distanceSort(vertices, uPlane, vPlane) {
    const centre = {};
    centre[uPlane] = 0;
    centre[vPlane] = 0;

    for (const vertex of vertices) {
        centre[uPlane] += vertex[uPlane];
        centre[vPlane] += vertex[vPlane];
    }

    centre[uPlane] /= vertices.length;
    centre[vPlane] /= vertices.length;

    for (const vertex of vertices) {
        vertex.distance = Math.hypot(
            vertex[uPlane] - centre[uPlane],
            vertex[vPlane] - centre[vPlane]
        );
    }

    const entries = Array.from(vertices.entries()).sort((a, b) => {
        if (a[1].distance > b[1].distance) {
            return 1;
        }

        if (a[1].distance < b[1].distance) {
            return -1;
        }

        return 0;
    });

    return entries.map((entry) => entry[0]);
}

// find the most-obvious 2D shape out of a face by creating a 2D polygon
// mapping two of the three planes (either (x, y), (x, z), (y, z))
function unwrapUVs(vertices) {
    const normal = arrayToVertex(
        getPlaneNormal(
            [],
            vertexToArray(vertices[0]),
            vertexToArray(vertices[1]),
            vertexToArray(vertices[vertices.length - 1])
        )
    );

    const min = { x: 0, y: 0, z: 0 };
    const max = { x: 0, y: 0, z: 0 };
    const length = { x: 0, y: 0, z: 0 };

    const area = { x: 0, y: 0, z: 0 };

    const changes = { x: 0, y: 0, z: 0 };
    const averageChanges = { x: 0, y: 0, z: 0 };
    const scaled = { x: 0, y: 0, z: 0 };

    for (const plane of ['x', 'y', 'z']) {
        min[plane] = getMinPlane(vertices, plane);
        max[plane] = getMaxPlane(vertices, plane);
        length[plane] = max[plane] - min[plane];

        area[plane] = getArea(vertices, plane);

        //changes[plane] = getMaxChange(vertices, plane);
        //averageChanges[plane] = getAverageChange(vertices, plane);
        //scaled[plane] = changes[plane] + getAverageChange(vertices, plane);
    }

    if (vertices.length === 4) {
        console.log(vertices);
        console.log('normal=', normal);
        //console.log('area=', area);
        //console.log('length=', length);
        //console.log('min=', min);
        //console.log(Array.from(vertices.entries()));
        //throw new Error();
    }

    /*if (vertices.length === 3) {
        if (test[0] === test[1]) {
            console.log(vertices);
            console.log('normal=',normal);
            console.log('area=', area);
            throw new Error();
        } else {
            //console.log(test);
        }
    }*/

    /*const firstDeltaX = vertices[0].x - vertices[1].x;
    const firstDeltaY = vertices[0].y - vertices[1].y;
    const firstDeltaZ = vertices[0].z - vertices[1].z;

    const lastDeltaX = vertices[vertices.length - 1].x - vertices[0].x;
    const lastDeltaY = vertices[vertices.length - 1].y - vertices[0].y;
    const lastDeltaZ = vertices[vertices.length - 1].z - vertices[0].z;

    console.log('firstDeltas=', firstDeltaX, ',', firstDeltaY, ',', firstDeltaZ);
    console.log('lastDeltas=', lastDeltaX, ',', lastDeltaY, ',', lastDeltaZ);*/

    /*let uPlane = null;
    let vPlane = null;

    if (scaled.x < scaled.y && scaled.x < scaled.z) {
        uPlane = 'y';
        vPlane = 'z';
    } else if (scaled.y < scaled.x && scaled.y < scaled.z) {
        uPlane = 'z';
        vPlane = 'x';
    } else if (scaled.z < scaled.x && scaled.z < scaled.y) {
        uPlane = 'x';
        vPlane = 'y';
    } else {
        console.log('len=', length);
        console.log('changes=', scaled);
        console.log('verts=', vertices);
        console.log('scaled=', scaled);

        //throw new Error("unable to unwrap UVs (can't figure out orientation)");
        console.log("unable to unwrap UVs (can't figure out orientation)");

        uPlane = 'x';
        vPlane = 'z';
    }*/

    let uPlane = 'x';
    let vPlane = 'y';

    if (
        Math.abs(normal.x) > Math.abs(normal.y) &&
        Math.abs(normal.x) > Math.abs(normal.z)
    ) {
        uPlane = 'z';
        vPlane = 'y';
    } else if (
        Math.abs(normal.y) > Math.abs(normal.x) &&
        Math.abs(normal.y) > Math.abs(normal.z)
    ) {
        uPlane = 'x';
        vPlane = 'z';
    } else if (
        Math.abs(normal.z) > Math.abs(normal.x) &&
        Math.abs(normal.z) > Math.abs(normal.y)
    ) {
        uPlane = 'x';
        vPlane = 'y';
    } else if (
        Math.abs(normal.x) < Math.abs(normal.y) &&
        Math.abs(normal.x) < Math.abs(normal.z)
    ) {
        uPlane = 'x';
        vPlane = 'y';
    } else if (
        Math.abs(normal.z) < Math.abs(normal.x) &&
        Math.abs(normal.z) < Math.abs(normal.y)
    ) {
        uPlane = 'z';
        vPlane = 'y';
    } else {
        console.log(vertices);
        console.log('normal=', normal);
        //console.log('area=', area);
        //throw new Error();
    }

    console.log('(',uPlane,',',vPlane,')');
    //console.log('sorted=', distanceSort(vertices, uPlane, vPlane).map(index => vertices[index]));
    //console.log('sorted=', rotationalSort(vertices, uPlane, vPlane));

    console.log();

    const sortedVertices = vertices;

    //const sortedVertices = rotationalSort(vertices, uPlane, vPlane).map(index => vertices[index]);
    //const sortedVertices = distanceSort(vertices, uPlane, vPlane).map(index => vertices[index]);

    let uvs = [];

    for (const vertex of sortedVertices) {
        let u = Math.abs(vertex[uPlane] - min[uPlane]) / length[uPlane];
        let v = Math.abs(vertex[vPlane] - min[vPlane]) / length[vPlane];

        if (normal[uPlane] > 0) {
            u = 1.0 - u;
        }

        if (normal[vPlane] < 0) {
            v = 1.0 - v;
        }

        uvs.push({ u, v });
    }

    uvs = uvSort(uvs);

    console.log('uvs=', uvs);

    return uvs;
}

module.exports = unwrapUVs;
