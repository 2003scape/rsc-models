const getPlaneNormal = require('get-plane-normal');

function getMinPlane(vertices, plane) {
    return Math.min(
        ...vertices.map((vertex) => {
            return vertex[plane];
        })
    );
}

function getMaxPlane(vertices, plane) {
    return Math.max(
        ...vertices.map((vertex) => {
            return vertex[plane];
        })
    );
}

function getMaxChange(vertices, plane) {
    let largest = 0;

    for (let i = 1; i < vertices.length; i++) {
        const delta = Math.abs(vertices[i][plane] - vertices[i - 1][plane]);

        if (delta > largest) {
            largest = delta;
        }
    }

    return largest;
}

function getAverageChange(vertices, plane) {
    let total = 0;

    for (let i = 1; i < vertices.length; i++) {
        const delta = Math.abs(vertices[i][plane] - vertices[i - 1][plane]);
        //console.log(vertices[i][plane],'-',vertices[i - 1][plane], '=', delta);
        total += delta;
    }

    return total / (vertices.length - 1);
}

function getArea(vertices, ignore) {
    let uPlane = 'x';
    let vPlane = 'y';

    if (ignore == 'x') {
        uPlane = 'y';
        vPlane = 'z';
    } else if (ignore == 'y') {
        vPlane = 'z';
    }

    let leftSum = 0;
    let rightSum = 0;

    for (let i = 0; i < vertices.length; i++) {
        const j = (i + 1) % vertices.length;
        leftSum += vertices[i][uPlane] * vertices[j][vPlane];
        rightSum += vertices[j][uPlane] * vertices[i][vPlane];
    }

    return 0.5 * (leftSum - rightSum); // removed abs
}

function vertexToArray({ x, y, z }) {
    return [x, y, z];
}

function arrayToVertex([x, y, z]) {
    return { x, y, z };
}

// find the most-obvious 2D shape out of a face by creating a 2D polygon
// mapping two of the three planes (either (x, y), (x, z), (y, z))
function unwrapUVs(vertices) {
    const normal = arrayToVertex(
        getPlaneNormal(
            [],
            vertexToArray(vertices[0]),
            vertexToArray(vertices[1]),
            vertexToArray(vertices[vertices.length - 1])
        )
    );

    const min = { x: 0, y: 0, z: 0 };
    const max = { x: 0, y: 0, z: 0 };
    const length = { x: 0, y: 0, z: 0 };

    const area = { x: 0, y: 0, z: 0 };

    const changes = { x: 0, y: 0, z: 0 };
    const averageChanges = { x: 0, y: 0, z: 0 };
    const scaled = { x: 0, y: 0, z: 0 };

    for (const plane of ['x', 'y', 'z']) {
        min[plane] = getMinPlane(vertices, plane);
        max[plane] = getMaxPlane(vertices, plane);
        length[plane] = max[plane] - min[plane];

        area[plane] = getArea(vertices, plane);

        //changes[plane] = getMaxChange(vertices, plane);
        //averageChanges[plane] = getAverageChange(vertices, plane);
        //scaled[plane] = changes[plane] + getAverageChange(vertices, plane);
    }

    //const test = normal.map(n=>Math.abs(n)).sort().reverse();

    if (vertices.length === 3) {
        console.log(vertices);
        console.log('normal=',normal);
        console.log('area=', area);
        console.log('length=', length);
        //throw new Error();
    }

    /*if (vertices.length === 3) {
        if (test[0] === test[1]) {
            console.log(vertices);
            console.log('normal=',normal);
            console.log('area=', area);
            throw new Error();
        } else {
            //console.log(test);
        }
    }*/

    /*const firstDeltaX = vertices[0].x - vertices[1].x;
    const firstDeltaY = vertices[0].y - vertices[1].y;
    const firstDeltaZ = vertices[0].z - vertices[1].z;

    const lastDeltaX = vertices[vertices.length - 1].x - vertices[0].x;
    const lastDeltaY = vertices[vertices.length - 1].y - vertices[0].y;
    const lastDeltaZ = vertices[vertices.length - 1].z - vertices[0].z;

    console.log('firstDeltas=', firstDeltaX, ',', firstDeltaY, ',', firstDeltaZ);
    console.log('lastDeltas=', lastDeltaX, ',', lastDeltaY, ',', lastDeltaZ);*/

    /*let uPlane = null;
    let vPlane = null;

    if (scaled.x < scaled.y && scaled.x < scaled.z) {
        uPlane = 'y';
        vPlane = 'z';
    } else if (scaled.y < scaled.x && scaled.y < scaled.z) {
        uPlane = 'z';
        vPlane = 'x';
    } else if (scaled.z < scaled.x && scaled.z < scaled.y) {
        uPlane = 'x';
        vPlane = 'y';
    } else {
        console.log('len=', length);
        console.log('changes=', scaled);
        console.log('verts=', vertices);
        console.log('scaled=', scaled);

        //throw new Error("unable to unwrap UVs (can't figure out orientation)");
        console.log("unable to unwrap UVs (can't figure out orientation)");

        uPlane = 'x';
        vPlane = 'z';
    }*/

    let uPlane = 'x';
    let vPlane = 'y';

    if (
        Math.abs(normal.x) > Math.abs(normal.y) &&
        Math.abs(normal.x) > Math.abs(normal.z)
    ) {
        uPlane = 'y';
        vPlane = 'z';
    } else if (
        Math.abs(normal.y) > Math.abs(normal.x) &&
        Math.abs(normal.y) > Math.abs(normal.z)
    ) {
        uPlane = 'x';
        vPlane = 'z';
    } else if (
        Math.abs(normal.z) > Math.abs(normal.x) &&
        Math.abs(normal.z) > Math.abs(normal.y)
    ) {
        uPlane = 'x';
        vPlane = 'y';
    } else if (
        Math.abs(normal.x) < Math.abs(normal.y) &&
        Math.abs(normal.x) < Math.abs(normal.z)
    ) {
        uPlane = 'x';
        vPlane = 'y';
    } else if (
        Math.abs(normal.z) < Math.abs(normal.x) &&
        Math.abs(normal.z) < Math.abs(normal.y)
    ) {
        uPlane = 'z';
        vPlane = 'y';
    } else {
        console.log(vertices);
        console.log('normal=', normal);
        console.log('area=', area);
        //throw new Error();
    }

    const uvs = [];

    for (const vertex of vertices) {
        let u = Math.abs(vertex[uPlane] - min[uPlane]) / length[uPlane];
        let v = Math.abs(vertex[vPlane] - min[vPlane]) / length[vPlane];

        if (normal[uPlane] > 0) {
            u = 1.0 - u;
        }

        if (normal[vPlane] < 0) {
            v = 1.0 - v;
        }

        uvs.push({ u, v });
    }

    return uvs;
}

module.exports = unwrapUVs;
